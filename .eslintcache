[{"/Users/bill/webgl-vj-generative/src/index.js":"1","/Users/bill/webgl-vj-generative/src/App.js":"2","/Users/bill/webgl-vj-generative/src/reportWebVitals.js":"3","/Users/bill/webgl-vj-generative/src/generateFragmentShader.js":"4","/Users/bill/webgl-vj-generative/src/Interface.js":"5"},{"size":500,"mtime":1611016938116,"results":"6","hashOfConfig":"7"},{"size":6458,"mtime":1611165486021,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":1611016938117,"results":"9","hashOfConfig":"7"},{"size":5172,"mtime":1611164703786,"results":"10","hashOfConfig":"7"},{"size":3395,"mtime":1611166407192,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1z0qm92",{"filePath":"15","messages":"16","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"14"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"14"},"/Users/bill/webgl-vj-generative/src/index.js",[],["26","27"],"/Users/bill/webgl-vj-generative/src/App.js",["28","29","30","31","32","33","34","35","36"],"import React from 'react'\nimport logo, { ReactComponent } from './logo.svg';\nimport './App.css';\nimport Interface from './Interface.js'\n\nimport * as d3 from 'd3'\n\nimport { generateFragmentShader, setDNA } from './generateFragmentShader.js'\n\nlet shaderInit \n\nconst vertexShader = `\n\nattribute vec3 position;\nvoid main() {\n  gl_Position = vec4( position, 1.0 );\n}\n`\n\nconst fragmentShader = `\n\nuniform float time;\nuniform vec2 resolution; \nvoid main( void ) { \n  vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;\n  float red = abs( sin( position.x * position.y + time / 5.0 ) );\n  float green = abs( sin( position.x * position.y + time / 4.0 ) );\n  float blue = abs( sin( position.x * position.y + time / 3.0 ) );\n  gl_FragColor = vec4( red, green, blue, 1.0 );\n} \n`\n\nconst emptyFragmentShader = `\n\nuniform float time;\nuniform float time2;\nuniform vec2 resolution; \nvoid main( void ) { \n  gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n} \n`\n\nconst fragmentShader2 = `\n\nuniform float time;\nuniform vec2 resolution; \nvoid main( void ) { \n  vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;\n  float red = abs( sin( position.x * position.y + time / .10 ) );\n  float green = abs( sin( position.x * position.y + time / .30 ) );\n  float blue = abs( sin( position.x * position.y + time / .20 ) );\n  gl_FragColor = vec4( red, green, blue, 1.0 );\n} \n`\n\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props)\n\n  }\n\n  componentDidMount () {\n\n    let counter = 0\n    window.requestAnimationFrame = window.requestAnimationFrame || ( function() {\n\n      return  window.webkitRequestAnimationFrame ||\n              window.mozRequestAnimationFrame ||\n              window.oRequestAnimationFrame ||\n              window.msRequestAnimationFrame ||\n              function(  callback, element ) {\n                window.setTimeout( callback, 1000 / 60 );\n              };\n\n    })();\n\n    var canvas, \n        gl, \n        buffer, \n        vertex_shader, fragment_shader, \n        currentProgram,\n        vertex_position,\n        timeLocation,\n        resolutionLocation,\n        parameters = {  start_time  : new Date().getTime(), \n                        time        : 0, \n                        screenWidth : 0, \n                        screenHeight: 0 };\n\n    init(emptyFragmentShader);\n    animate();\n\n    function init(fragmentShader) {\n\n      // console.log(fragmentShader)\n\n      vertex_shader = vertexShader\n      fragment_shader = fragmentShader\n\n      canvas = document.querySelector( 'canvas' );\n\n      // Initialise WebGL\n\n      try {\n\n        gl = canvas.getContext( 'experimental-webgl' );\n\n      } catch( error ) { }\n\n      if ( !gl ) {\n\n        throw \"cannot create webgl context\";\n\n      }\n\n      // Create Vertex buffer (2 triangles)\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n      gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );\n\n      // Create Program\n\n      currentProgram = createProgram( vertex_shader, fragment_shader );\n      parameters.start_time = new Date().getTime()\n      timeLocation = gl.getUniformLocation( currentProgram, 'time' );\n      resolutionLocation = gl.getUniformLocation( currentProgram, 'resolution' );\n\n    }\n\n    window.shaderInit = init\n\n    function createProgram( vertex, fragment ) {\n\n      var program = gl.createProgram();\n\n      var vs = createShader( vertex, gl.VERTEX_SHADER );\n      var fs = createShader( '#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n' + fragment, gl.FRAGMENT_SHADER );\n\n      if ( vs == null || fs == null ) { \n        console.log(vs,fs)\n        return null;\n      }\n\n      console.log(vs)\n\n      gl.attachShader( program, vs );\n      gl.attachShader( program, fs );\n\n      gl.deleteShader( vs );\n      gl.deleteShader( fs );\n\n      gl.linkProgram( program );\n\n      if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {\n\n        alert( \"ERROR:\\n\" +\n        \"VALIDATE_STATUS: \" + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + \"\\n\" +\n        \"ERROR: \" + gl.getError() + \"\\n\\n\" +\n        \"- Vertex Shader -\\n\" + vertex + \"\\n\\n\" +\n        \"- Fragment Shader -\\n\" + fragment );\n\n        return null;\n\n      }\n\n      return program;\n\n    }\n\n    function createShader( src, type ) {\n\n      var shader = gl.createShader( type );\n\n      gl.shaderSource( shader, src );\n      gl.compileShader( shader );\n\n      if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {\n\n        alert( ( type == gl.VERTEX_SHADER ? \"VERTEX\" : \"FRAGMENT\" ) + \" SHADER:\\n\" + gl.getShaderInfoLog( shader ) );\n        return null;\n\n      }\n\n      return shader;\n\n    }\n\n    function resizeCanvas( event ) {\n\n      if ( canvas.width != canvas.clientWidth ||\n         canvas.height != canvas.clientHeight ) {\n\n        canvas.width = canvas.clientWidth;\n        canvas.height = canvas.clientHeight;\n\n        parameters.screenWidth = canvas.width;\n        parameters.screenHeight = canvas.height;\n\n        gl.viewport( 0, 0, canvas.width, canvas.height );\n\n      }\n\n    }\n\n    function animate() {\n\n      resizeCanvas();      \n      render();\n\n      counter += 1\n      if(counter > 3000000000) {\n        counter = 0\n        setDNA({data: d3.range(128).map(o=>{return Math.floor(Math.random()*12)}) })\n        init(generateFragmentShader())\n        parameters.start_time = new Date().getTime()\n      }\n\n      requestAnimationFrame( animate );\n\n    }\n\n    function render() {\n      \n      if ( !currentProgram ) return;\n\n      parameters.time = new Date().getTime() - parameters.start_time;\n\n      gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n\n      // Load program into GPU\n\n      gl.useProgram( currentProgram );\n\n      // Set values to program variables\n\n      gl.uniform1f( timeLocation, parameters.time / 1000 );\n      gl.uniform2f( resolutionLocation, parameters.screenWidth, parameters.screenHeight );\n\n      // Render geometry\n\n      gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n      gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );\n      gl.enableVertexAttribArray( vertex_position );\n      gl.drawArrays( gl.TRIANGLES, 0, 6 );\n      gl.disableVertexAttribArray( vertex_position );\n\n    }    \n  }\n\n  render () {\n    return (\n      <div className=\"App\">\n         <canvas></canvas>\n        <Interface fns={{generateFragmentShader, setDNA, shaderInit}}/>\n      </div>\n    );\n  }\n\n}\n\n\nexport default App","/Users/bill/webgl-vj-generative/src/reportWebVitals.js",[],"/Users/bill/webgl-vj-generative/src/generateFragmentShader.js",["37","38"],"let compoundArgumentsLength = 6\nlet genesLength = 180\nlet linesLength = 120\n\nlet currentDNAIndex = 0\nlet dna = []\n\nfor (let i = 0; i < genesLength; i++) {\n  dna.push(Math.floor(Math.random()*12))\n}\n\nconst functions = [\n  { name: '', args: 1 }, \n  { name: 'sin', args: 1 },\n  { name: 'cos', args: 1 },\n  { name: 'tan', args: 1 },\n  { name: 'abs', args: 1 },\n  { name: 'fract', args: 1 }\n]\n\nconst operatorsAssign = [\n  { name: '+=' },\n  { name: '-=' },\n  { name: '*=' },\n  { name: '=' },\n  // { name: '/=' }\n]\n\nconst operatorsSimple = [\n  { name: '*' },\n  { name: '+' },\n  { name: '-' },\n  { name: '/' }\n]\n\nconst values = [\n  { name: 'red' },\n  { name: 'green' },\n  { name: 'blue' },\n  { name: 'timeMulti' },\n]\n\nconst constantValues = [\n  { name: 'position.x' },\n  { name: 'position.y' },\n  { name: 'time' },\n  { name: 'time2' },\n  { name: 'time*timeMulti' },\n  { name: 'time/timeMulti' },\n  { name: 'distanceToCenter' },\n  { name: 'distanceToBottomLeft' },\n  { name: 'distanceToBottomRight' },\n  { name: 'distanceToTopLeft' },\n  { name: 'distanceToTopRight' },\n  { name: 'red' },\n  { name: 'green' },\n  { name: 'blue' },\n]\n\nfunction createLine() {\n  return [\n    r(values).name,\n    r(operatorsAssign).name,\n    r(functions).name + '(',\n    createCompoundValue(1+Math.floor(Math.random()*compoundArgumentsLength)),\n    ');'\n  ].join(' ')\n}\n\nfunction createCompoundValue(n) {\n  const values = []\n  for(let i = 0; i < n; i++) {\n    if(i !== n-1) {\n      values.push([r(constantValues).name, r(operatorsSimple).name].join(' '))\n    } else {\n      values.push(r(constantValues).name)\n    }    \n  }\n  return values.join(' ')\n}\n\nfunction r(arr) {\n  return arr[Math.floor(Math.random()*arr.length)]\n}\n\nfunction createLineDNA() {\n\n  const leftGene = dna[currentDNAIndex]\n  currentDNAIndex++\n  currentDNAIndex = currentDNAIndex % dna.length\n  // console.log(currentDNAIndex)\n  const operatorGene = dna[currentDNAIndex]\n  currentDNAIndex++\n  currentDNAIndex = currentDNAIndex % dna.length\n  // console.log(currentDNAIndex)\n  const functionGene = dna[currentDNAIndex]\n  currentDNAIndex++\n  currentDNAIndex = currentDNAIndex % dna.length\n  // console.log(currentDNAIndex)\n  \n  let valueLengthGene = (dna[currentDNAIndex] % compoundArgumentsLength) + 1\n  if(valueLengthGene % 2 === 0) {\n    valueLengthGene += 1\n  }\n  currentDNAIndex++\n  currentDNAIndex = currentDNAIndex % dna.length\n  // console.log('value length gene', valueLengthGene)\n  const valueGenes = []\n  for(let i = 0; i < valueLengthGene; i++) {\n    valueGenes.push(dna[currentDNAIndex])\n    currentDNAIndex++\n    currentDNAIndex = currentDNAIndex % dna.length\n  }\n\n  // console.log({leftGene,operatorGene,functionGene,valueLengthGene,valueGenes})\n\n  return [\n    rDNA(values, leftGene).name,\n    rDNA(operatorsAssign, operatorGene).name,\n    rDNA(functions, functionGene).name + '(',\n    createCompoundValueDNA(valueGenes),\n    ');'\n  ].join(' ')\n}\n\nfunction createCompoundValueDNA(genes) {\n  let geneIndex = 0\n  const values = []\n  // console.log('genes length', genes.length)\n  while(genes.length > 0) {\n    if(genes.length >= 2) {\n      values.push(\n        [\n          rDNA(constantValues,genes.pop()).name, \n          rDNA(operatorsSimple,genes.pop()).name\n        ].join(' ')\n      )\n    } else {\n      values.push(rDNA(constantValues, genes.pop()).name)\n    }  \n  }\n  return values.join(' ')\n}\n\nfunction rDNA(arr, value) {\n  // console.log('array length', arr.length, 'asked index', value, 'computed index', value%arr.length)\n  return arr[value%(arr.length)]\n}\n\nfunction generateFragmentShader() {\n\n  const lines = []\n  lines.push('uniform float time;')\n  lines.push('uniform vec2 resolution;')\n  lines.push('void main ( void ) {')\n  lines.push('vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;')\n  lines.push('vec2 centerPosition = vec2(resolution.x*0.5, resolution.y*0.5);')\n  lines.push('float distanceToCenter = (1.0/resolution.x) * 3.14 * distance(gl_FragCoord.xy, centerPosition);')\n  lines.push('float distanceToTopLeft = (1.0/resolution.x) * distance(gl_FragCoord.xy, vec2(0,0));')\n  lines.push('float distanceToTopRight = (1.0/resolution.x) * distance(gl_FragCoord.xy, vec2(resolution.x,0));')\n  lines.push('float distanceToBottomLeft = (1.0/resolution.x) * distance(gl_FragCoord.xy, vec2(0,resolution.y));')\n  lines.push('float distanceToBottomRight = (1.0/resolution.x) * distance(gl_FragCoord.xy, resolution.xy);')  \n  lines.push('float timeMulti = 0.0;')\n  lines.push('float time2 = time * 0.1;')\n  lines.push('float red = 0.0;')\n  lines.push('float green = 0.0;')\n  lines.push('float blue = 0.0;')\n\n  for(let i = 0; i < linesLength; i++) {\n    lines.push(createLineDNA())\n  }\n\n  lines.push('gl_FragColor = vec4( red, green, blue, 1.0 );')\n  lines.push('}')\n\n  const displayLines = []\n  lines.forEach((line,lineIndex)=>{\n    displayLines.push([lineIndex,line].join('\\t'))\n  })\n  // console.log(displayLines.join('\\n'))\n\n  return lines.join('\\n')\n\n}\n\nfunction setDNA(options) {\n  dna = []\n  currentDNAIndex = 0\n  options.data.forEach(d=>{\n    dna.push(d)\n  })\n}\nfunction configure(options) {\n  linesLength = options.linesLength\n}\n\nexport {\n  configure,\n  generateFragmentShader,\n  setDNA\n}","/Users/bill/webgl-vj-generative/src/Interface.js",["39"],"import React from 'react'\nimport * as d3 from 'd3'\n\nexport default class Interface extends React.Component {\n\n  constructor(props) {\n    super(props)\n    this.svgRef = React.createRef()\n    this.bitRate = 4\n    this.geneSize = 64\n    this.bits = d3.range(this.bitRate * this.geneSize).map(o=>{\n      // return 0\n      return Math.random() > 0.5 ? 1 : 0\n    })\n    console.log(this.props, 'props')\n    this.convertBits = this.convertBits.bind(this)\n    console.log(d3.drag)\n  }\n\n  convertBits () {\n    const bytes = []\n    for(let i = 0; i < this.geneSize*this.bitRate; i+=this.bitRate) {\n      const bitArray = d3.range(this.bitRate).map(offset=>{ return this.bits[i+offset] })\n      // console.log(bitArray)\n      bytes.push(parseInt(bitArray.join(''),2))\n    }\n    console.log('bytes', bytes)\n    return bytes\n  }\n\n  componentDidMount () {\n    console.log('interface mounted')\n    const svg = d3.select(this.svgRef.current)\n      .attr('viewBox', '-5 -5 110 110')\n      .attr('width', window.innerHeight*0.8)\n    const gridSize = Math.floor(Math.sqrt(this.bits.length)) \n    const boxSize = 100 / gridSize\n    const g = svg.append('g')\n    const drag = d3.drag()\n    \n    let dragFlipped = []\n    drag.on('drag', (event)=>{\n      console.log('drag event', event.x, event.y)\n      const x = Math.floor(event.x / boxSize)\n      const y = Math.floor(event.y / boxSize)\n      const index = (y*gridSize) + x\n      console.log(x,y)\n      // if(dragFlipped.indexOf(index) === -1) {\n      if(dragFlipped[dragFlipped.length-1] !== index) {\n        dragFlipped.push(index)\n        if(this.bits[index] === 1) {\n          this.bits[index] = 0\n        } else {\n          this.bits[index] = 1\n        }\n        g.select('rect#_'+index).attr('fill', this.bits[index] === 1 ? 'white' : 'black')      \n        this.props.fns.setDNA({data:this.convertBits()})\n        window.shaderInit(this.props.fns.generateFragmentShader())    \n      }\n    })\n    \n    drag.on('start', (event)=>{\n      dragFlipped = []\n      console.log(\"DRAG START\")\n    })\n    g.call(drag)\n\n    // generate rectangles\n    let x = 0\n    let y = 0\n    this.bits.forEach((bit,bitIndex)=>{     \n      y = Math.floor(bitIndex / gridSize) \n      x = bitIndex - (y*gridSize)\n      const rect = g.append('rect').attr('id', '_'+bitIndex)\n        .attr('x',x*boxSize).attr('y',y*boxSize)\n        .attr('width', boxSize).attr('height', boxSize)\n        .attr('fill', bit === 1 ? 'white' : 'black')      \n\n      rect.on('click', ()=>{\n        return\n        if(this.bits[bitIndex] === 1){\n          this.bits[bitIndex] = 0\n        } else {\n          this.bits[bitIndex] = 1\n        }\n        // convertBits\n        // this.props.setDNA({ data: this.bits })\n        // this.convertBits()\n        rect.attr('fill', this.bits[bitIndex] === 1 ? 'white' : 'black')      \n        this.props.fns.setDNA({data:this.convertBits()})\n        window.shaderInit(this.props.fns.generateFragmentShader())\n      })\n      x += 1\n      if(x > gridSize) {\n        y += 1\n        x = 0\n      }  \n    })\n\n    setTimeout(()=>{\n      this.props.fns.setDNA({data:this.convertBits()})\n      window.shaderInit(this.props.fns.generateFragmentShader())  \n    },10)\n  }\n\n  render () {\n    return (\n      <div style={{ position: 'absolute', top: 0, left: 0, opacity: 0.3, backgroundColor: 'rgba(0,0,0,0)', width: '100%' }}>\n        <svg ref={this.svgRef}/>\n      </div>\n    )\n  }\n}",{"ruleId":"40","replacedBy":"41"},{"ruleId":"42","replacedBy":"43"},{"ruleId":"44","severity":1,"message":"45","line":2,"column":8,"nodeType":"46","messageId":"47","endLine":2,"endColumn":12},{"ruleId":"44","severity":1,"message":"48","line":2,"column":16,"nodeType":"46","messageId":"47","endLine":2,"endColumn":30},{"ruleId":"44","severity":1,"message":"49","line":20,"column":7,"nodeType":"46","messageId":"47","endLine":20,"endColumn":21},{"ruleId":"44","severity":1,"message":"50","line":43,"column":7,"nodeType":"46","messageId":"47","endLine":43,"endColumn":22},{"ruleId":"51","severity":1,"message":"52","line":58,"column":3,"nodeType":"53","messageId":"54","endLine":61,"endColumn":4},{"ruleId":"55","severity":1,"message":"56","line":113,"column":9,"nodeType":"57","messageId":"58","endLine":113,"endColumn":45},{"ruleId":"59","severity":1,"message":"60","line":181,"column":23,"nodeType":"61","messageId":"62","endLine":181,"endColumn":25},{"ruleId":"59","severity":1,"message":"63","line":192,"column":25,"nodeType":"61","messageId":"62","endLine":192,"endColumn":27},{"ruleId":"59","severity":1,"message":"63","line":193,"column":24,"nodeType":"61","messageId":"62","endLine":193,"endColumn":26},{"ruleId":"44","severity":1,"message":"64","line":60,"column":10,"nodeType":"46","messageId":"47","endLine":60,"endColumn":20},{"ruleId":"44","severity":1,"message":"65","line":127,"column":7,"nodeType":"46","messageId":"47","endLine":127,"endColumn":16},{"ruleId":"66","severity":1,"message":"67","line":81,"column":9,"nodeType":"68","messageId":"69","endLine":91,"endColumn":67},"no-native-reassign",["70"],"no-negated-in-lhs",["71"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'ReactComponent' is defined but never used.","'fragmentShader' is assigned a value but never used.","'fragmentShader2' is assigned a value but never used.","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'createLine' is defined but never used.","'geneIndex' is assigned a value but never used.","no-unreachable","Unreachable code.","IfStatement","unreachableCode","no-global-assign","no-unsafe-negation"]